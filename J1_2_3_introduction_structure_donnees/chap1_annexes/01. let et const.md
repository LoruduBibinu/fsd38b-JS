# `let` et `const` en JS

---

## Les probl√®mes de `var`

Avant ES2015, la seule mani√®re de d√©clarer des variables en JS √©tait d'utiliser le mot-cl√© `var`

```js
var prenom = 'John';
var nom = 'DOE';
var age = 42;
var isStudent = false;
```

Un premier probl√®me de `var` est qu'on peut re-d√©clarer la m√™me variable plusieurs fois.

```js
var prenom = 'Marie';
// ‚Ä¶
var prenom = 'Jean'; // Tout va bien ‚Ä¶ üôÑ
```

C'est sale, et √ßa augmente surtout le risque d'erreurs √† long terme.

Autre soucis avec `var` : **la persistance de la variable.**

Il est fr√©quent d'utiliser des variables uniquement pour les besoins d'un bloc `for` ou d'un `if` :

```js
var tableau = ['jason', 'andrew', 'julian'];
for (var i = 0; i < tableau.length; i++) {
    // ‚Ä¶
}

console.log(i); // Affiche: 3
```

Ici, La variable `i` existe encore en m√©moire apr√®s la fin de la boucle, alors qu'elle n'a plus aucune utilit√© üòê

Autre probl√®me lors d'une boucle : la m√™me variable est r√©-utilis√©e √† chaque tour, rendant compliqu√©e la gestion de code asynchrone :

```js
// S√©lectionne tous les √©l√©ments <button> du HTML
var buttons = document.querySelectorAll('button');

for (var i = 0; i < buttons.length; i++) {
    buttons[i].onclick = function() {
        console.log('Clic sur buttons[' +  i  + ']');
    }
}
```

Ici, la valeur de `i` au moment de l'ex√©cution de la fonction `onclick` aura toujours la valeur finale de l'incr√©mentation (et non celle de l'index du bouton comme on le voudrait üòì)

De plus, une d√©claration de variable avec var est **hoist√©e** et initialis√©e √† `undefined`, d'o√π un nouveau probl√®me :

```js
console.log(name); // undefined

var name = 'Jason Statham'; 
```

Ce code devrait logiquement produire une `ReferenceError`, mais il affiche pourtant `undefined`

### Le scope üî≠

Le scope d√©finit l'endroit o√π les variables du programme sont accessibles :

```js
// scope global
var date = new Date();

function getYear () {
  // --------- scope de la fonction ----------
    var year = date.getFullYear();

    return year;
  // ------ fin du scope de la fonction ------
}

getYear();
console.log(date); // ‚úÖ
console.log(year); // ‚ùå ReferenceError
```

La variable `year` est d√©finie dans le **scope de la fonction**,
et par cons√©quent n'est pas accessible √† l'**ext√©rieur** de celle-ci.

### A retenir

Une variable d√©clar√©e avec `var` est accessible soit :

- dans le scope **global**
- dans le scope **de la fonction o√π elle est d√©clar√©e**

Ce sont les deux seuls scopes pour une `var` ‚Ä¶

### Moralit√©**

``var`` est √† l'origine de plusieurs probl√®mes et ne devrait plus √™tre utilis√© dans une base de code JS moderne.

---

## D√©clarer une variable avec `let`

Globalement, on remplace juste var par let :

```js
let prenom = 'John';
let nom = 'DOE';
let age = 42;
let isStudent = false;  
```

D√©j√†, avec `let`, il n'est plus possible de re-d√©clarer la m√™me variable une seconde fois dans le programme :

```js
let prenom = 'Jean';
// ‚Ä¶
let prenom = 'Marie';
// ‚ùå SyntaxError: 'prenom' has already been declared
```
C'est une bonne chose car cela √©vite d'√©crire du mauvais code √† long terme.

Ensuite, une variable `let` est **locale au scope du bloc o√π elle est d√©clar√©e** :

```js
for (let i = 0; i < tableau.length; i++) {
    // ‚Ä¶
}

/* La variable "i" n'existe plus ici, car elle √©tait limit√©e
    au scope du bloc for() */
```

C'est une bonne chose car `i` n'a plus aucune utilit√© apr√®s la boucle.

Comme un **scope distinct** est cr√©√© pour chaque it√©ration, il n'y a plus de probl√®me non plus √† utiliser un code asynchrone pendant la boucle :

```js
// S√©lectionne tous les √©l√©ments <button> du HTML
let buttons = document.querySelectorAll('button');

for (let i = 0; i < buttons.length; i++) {
    buttons[i].onclick = function() {
        console.log('Clic sur buttons[' +  i  + ']');
    }
}
```

Ici, lorsqu'on cliquera sur un bouton, la valeur de `i` correspondra bien √† l'index du tableau associ√© au bouton cliqu√© (et g√©n√©ralement c'est ce qu'on veut üòÉ).

Enfin, une d√©claration de variable avec let est toujours **hoist√©e** mais non initialis√©e :

```js
console.log(name); // ‚ùå ReferenceError: name is not defined

let name = 'Jason Statham'; 
```

Ce code produit bien une `ReferenceError` comme on s'y attend (il ne devrait pas √™tre normal de tenter d'utiliser une variable avant de l'avoir d√©clar√©e).

### Moralit√©

Il n'y a plus vraiment d'avantage √† utiliser `var` en JS moderne.

G√©n√©ralement, on utilise plut√¥t `let` üëç

## D√©clarer une constante avec `const`

Une constante repr√©sente une valeur accessible en **lecture seule**.

On la d√©clare de la m√™me fa√ßon qu'une variable, mais avec le mot-cl√© `const` :

```js
// R√©-assignation d'une variable :
let day = 15;
day = 16; // ‚úÖ Ok


// Tentative de r√©-assignation d'une constante :
const year = 2020;
year = 2021; // ‚ùå TypeError: Assignment to constant variable.
```

Attention, si la constante r√©f√©rence un objet JS, les propri√©t√©s de cet objet peuvent toutefois √™tre mut√©es :

```js
const person = { name : 'Steve' , age : 39 };

/* Ici, seules les propri√©t√©s de l'objet changent,
    et non l'objet lui-m√™me, donc √ßa passe */

person.age++; // ‚úÖ
person.name = 'Tim'; // ‚úÖ
person.lastname = 'Cook'; // ‚úÖ
```

Concernant le scope, les m√™me r√®gles s'appliquent pour `const` et pour `let`.

### Moralit√©

On utilise g√©n√©ralement une `const` si on sait que notre valeur n'aura pas √† changer plus tard dans le programme (ce qui est souvent le cas pour des objets que l'on fait muter).

Si on sait que la valeur pourra √™tre modifi√©e, on utilisera alors un `let`

---

# Annexes :

Documentation MDN sur `var`, `let` et `const` : https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions#D%C3%A9clarations